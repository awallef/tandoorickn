package  com.tandoorickn.patterns.process{	import com.tandoorickn.interfaces.patterns.IProcess;		public class ProcessorFactory {				public var stack		:Object;									public function ProcessorFactory()		{			stack 		= {};		}				public function addProcess(process:Process):void		{			stack[process.name] = process;		}				public function registerProcess(name:String,args:Array,once:Boolean):void		{			var process:Process = new Process(name,args,once);			stack[name] = process;		}				public function removeProcess(name:String, andDistroy:Boolean = false):void		{			var process:Process = ( stack[name] as Process);			if(andDistroy) process.kill();			stack[name] = null;		}				public function addCommandAt(name:String,index:uint,commands:Array):void		{												switch(index)			{				case 0:					//( stack[name] as Process).stack.unshift(commands);					( stack[name] as Process).stack = commands.concat(( stack[name] as Process).stack);					break;								case ( stack[name] as Process).stack.length:					( stack[name] as Process).stack = ( stack[name] as Process).stack.concat(commands);					break;								default:					var old:Array = ( stack[name] as Process).stack;					var partOne:Array = old.slice(0, index);										var partTwo:Array = old.slice(index);										partOne = partOne.concat(commands);					( stack[name] as Process).stack = partOne.concat(partTwo);			}											}						public function removeAllProcess(andDistroy:Boolean = false):void		{			for( var i:String in stack) removeProcess(( stack[i] as Process).name,andDistroy);		}				public function setProcessForward(name:String ="",amount:int = 1):void		{			(stack[name] as Process).count+= amount;		}	}	}