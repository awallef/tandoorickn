package  com.tandoorickn.patterns.sequencer{		import com.tandoorickn.debug.Log;	import com.tandoorickn.patterns.facade.AbstractFacade;	import com.tandoorickn.patterns.workflow.AbstractWorkflow;		import org.puremvc.as3.interfaces.*;	import org.puremvc.as3.patterns.observer.Notification;
	public class Sequencer {				public var 		facade			:AbstractFacade;				private var 	_timeline		:Object,						_cronStack		:Object;										public function Sequencer()		{			_timeline = {};			_cronStack = {};		}						/* LABELS		**********************************************/		public function addActionAt(name:String, label:String):void		{			if(!_timeline[label]) _timeline[label] = new Array();				_timeline[label].push(name);		}				public function addLabel(label:String):void		{			if(!_timeline[label]) _timeline[label] = new Array();		}				public function hasLabel(label:String):Boolean		{			return (_timeline[label])? true: false; 		}						/* GOTO		**********************************************/				public function goto(labelOrName:String, body:Object = null, type:String = null):void		{			if(body == null) body = {};						if(hasLabel(labelOrName))			{				for( var i:uint = 0; i < _timeline[labelOrName].length; i++) exec(_timeline[labelOrName][i],body,type);			}			else			{				exec(labelOrName,body,type);			}		}						/* CRON JOB		**********************************************/				public function addCronJob(labelOrName:String, delay:Number, note:Object = null, stopCount:int = -1):void		{			if(!_cronStack[labelOrName]) 			{				_cronStack[labelOrName] = new CronJob(this.cronExec,labelOrName,delay,note,stopCount);			}else{				var cron:CronJob = _cronStack[labelOrName] as CronJob;				cron.stop();				cron.labelOrName = labelOrName;				cron.delay = delay;				cron.note = note;				cron.stopCount = stopCount;			}		}				public function startCronJob(labelOrName:String):void		{			if(_cronStack[labelOrName]) (_cronStack[labelOrName] as CronJob).start();		}				public function stopCronJob(labelOrName:String, andDestroy:Boolean = false):void		{			if(_cronStack[labelOrName])			{				(_cronStack[labelOrName] as CronJob).stop();				if(andDestroy)				{					(_cronStack[labelOrName] as CronJob).destroy();					_cronStack[labelOrName] = null;				}							}		}				public function stopAllCronJob(andDestroy:Boolean = false):void		{			for(var i:String in _cronStack)			{				(_cronStack[i] as CronJob).stop();				if(andDestroy)				{					(_cronStack[i] as CronJob).destroy();					_cronStack[i] = null;				}			}		}				private function cronExec(labelOrName:String, body:Object = null, type:String = null):void		{			Log.info("Sequencer","cronExec",labelOrName);			this.goto(labelOrName, body, type);		}				/* PRIVATE		**********************************************/								private function exec(name:String, body:Object = null, type:String = null):void		{			if(facade.workflow.hasWorkflow(name))			{				facade.workflow.execute(name,new Notification("Sequencer.goto."+name,body,type));				return;			}						if(facade.macro.hasMacro(name))			{				facade.macro.execute(name,new Notification("Sequencer.goto."+name,body,type));				return;			}						if(facade.process.hasProcess(name))			{				facade.process.execute(name,new Notification("Sequencer.goto."+name,body,type));				return;			}						if(facade.hasCommand(name))			{				facade.sendNotification(name,body,type);				return;			}						Log.warn("Sequencer","label or name:",name,"doesn't exist at all !!!!");			return;		}			}	}