package  com.tandoorickn.ui.css.utils{		import com.tandoorickn.ui.css.core.CoreCssSprite;	import flash.display.Graphics;	import flash.geom.Point;	import flash.geom.Matrix;	import flash.display.GradientType;	import flash.display.SpreadMethod;		public class CssDraw {		public static function draw(cssSprite:CoreCssSprite,horz:Array,vert:Array):void		{			cssSprite.graphics.clear();						/*// OUTSIDE			cssSprite.graphics.beginFill(0xFF0000);			cssSprite.graphics.drawRect(horz[0].x,vert[0].x,horz[0].y,vert[0].y);						// margin			cssSprite.graphics.beginFill(0x00FF00);			cssSprite.graphics.drawRect(horz[1].x,vert[1].x,horz[1].y,vert[1].y);						// border			cssSprite.graphics.beginFill(0x0000FF);			cssSprite.graphics.drawRect(horz[2].x,vert[2].x,horz[2].y,vert[2].y);						// padding			cssSprite.graphics.beginFill(0xFF00FF);			cssSprite.graphics.drawRect(horz[3].x,vert[3].x,horz[3].y,vert[3].y);*/						CssDraw.drawBorders(cssSprite,horz[1].x,vert[1].x,horz[1].y,vert[1].y);			CssDraw.drawBackGround(cssSprite,horz[2].x,vert[2].x,horz[2].y,vert[2].y);								}				private static function drawBorders(cssSprite:CoreCssSprite,x:Number,y:Number,width:Number,height:Number):void		{			var g:Graphics = cssSprite.graphics;			var rad:Array = cssSprite.style.borderRadius;						if(cssSprite.style.borderTop[0] == 0 && cssSprite.style.borderRight[0] == 0 && cssSprite.style.borderBottom[0] == 0 && cssSprite.style.borderLeft[0] == 0) return;						// peace top			if(cssSprite.style.borderTop[0] != 0 )			{				g.beginFill(cssSprite.style.borderTop[1],cssSprite.style.borderTop[2]);				g.drawRect(x + cssSprite.style.borderLeft[0] + rad[0] ,y,width - (  cssSprite.style.borderLeft[0] + rad[0] + cssSprite.style.borderRight[0] + rad[1] ), cssSprite.style.borderTop[0]);			}						// peace right			if(cssSprite.style.borderRight[0] != 0 )			{				g.beginFill(cssSprite.style.borderRight[1],cssSprite.style.borderRight[2]);				g.drawRect((x + width ) - cssSprite.style.borderRight[0] ,y + cssSprite.style.borderTop[0] + rad[1] ,cssSprite.style.borderRight[0], height - ( cssSprite.style.borderTop[0] + rad[1] + cssSprite.style.borderBottom[0] + rad[2]) );			}						// peace bottom			if(cssSprite.style.borderBottom[0] != 0 )			{				g.beginFill(cssSprite.style.borderBottom[1],cssSprite.style.borderBottom[2]);				g.drawRect(x + (cssSprite.style.borderLeft[0] + rad[3] ) , y + height - cssSprite.style.borderBottom[0] ,width - (  cssSprite.style.borderLeft[0] + rad[3] + cssSprite.style.borderRight[0] + rad[2] ), cssSprite.style.borderBottom[0]);			}						// peace left			if(cssSprite.style.borderLeft[0] != 0 )			{				g.beginFill(cssSprite.style.borderLeft[1],cssSprite.style.borderLeft[2]);				g.drawRect(x ,y + cssSprite.style.borderTop[0] + rad[0] ,cssSprite.style.borderLeft[0], height - ( cssSprite.style.borderTop[0] + rad[0] + cssSprite.style.borderBottom[0] + rad[3]) );			}						// corner top left			if(cssSprite.style.borderLeft[0] != 0 || cssSprite.style.borderTop[0] != 0)			{								CssDraw.makeBorderGradient(g,cssSprite.style.borderLeft[1],cssSprite.style.borderTop[1],cssSprite.style.borderLeft[2],cssSprite.style.borderTop[2],cssSprite.style.borderLeft[0] + rad[0], cssSprite.style.borderTop[0] + rad[0], Math.PI / -4);								//g.beginFill(0x00FF00);				g.moveTo(x + cssSprite.style.borderLeft[0] ,y + rad[0] + cssSprite.style.borderTop[0]);				g.lineTo(x ,y + cssSprite.style.borderTop[0] + rad[0]);				if(rad[0] != 0) g.curveTo(x,y,x + rad[0] + cssSprite.style.borderLeft[0] ,y);				else {					g.lineTo(x ,y);					g.lineTo(x + cssSprite.style.borderLeft[0],y);				}				g.lineTo(x + rad[0] + cssSprite.style.borderLeft[0] ,y +  cssSprite.style.borderTop[0]);				if(rad[0] != 0)				{					g.curveTo(x + cssSprite.style.borderLeft[0] ,y + cssSprite.style.borderTop[0] ,x + cssSprite.style.borderLeft[0] ,y + rad[0] + cssSprite.style.borderTop[0]);				}				else g.lineTo(x + cssSprite.style.borderLeft[0] ,y + cssSprite.style.borderTop[0]);				g.endFill();			}									// corner top right			if(cssSprite.style.borderTop[0] != 0 || cssSprite.style.borderRight[0] != 0)			{				CssDraw.makeBorderGradient(g,cssSprite.style.borderTop[1],cssSprite.style.borderRight[1],cssSprite.style.borderTop[2],cssSprite.style.borderRight[2],cssSprite.style.borderTop[0] + rad[1], cssSprite.style.borderRight[0] + rad[1], 45, x + width - cssSprite.style.borderRight[0] - rad[1], y);								//g.beginFill(0x00FF00);				g.moveTo((x + width) - (cssSprite.style.borderRight[0] + rad[1]) , y + cssSprite.style.borderTop[0]);				g.lineTo((x + width ) - ( cssSprite.style.borderRight[0] + rad[1] ) ,y);				if(rad[1] != 0) g.curveTo(x + width,y, x + width ,y + cssSprite.style.borderTop[0] + rad[1]);				else{					g.lineTo(x + width ,y);					g.lineTo(x + width ,y + cssSprite.style.borderTop[0]);				}				g.lineTo((x + width) - (cssSprite.style.borderRight[0] ) , y + cssSprite.style.borderTop[0] + rad[1]);				if(rad[1] != 0)				{					g.curveTo((x + width) - (cssSprite.style.borderRight[0] ) ,y + cssSprite.style.borderTop[0] ,(x + width) - (cssSprite.style.borderRight[0] + rad[1]) , y + cssSprite.style.borderTop[0]);				}				else g.lineTo((x + width) - (cssSprite.style.borderRight[0] + rad[1]) , y + cssSprite.style.borderTop[0]);				g.endFill();			}									// corner bottom right			if(cssSprite.style.borderRight[0] != 0 || cssSprite.style.borderBottom[0] != 0)			{				CssDraw.makeBorderGradient(g,cssSprite.style.borderRight[1],cssSprite.style.borderBottom[1],cssSprite.style.borderRight[2],cssSprite.style.borderBottom[2],cssSprite.style.borderRight[0] + rad[2], cssSprite.style.borderBottom[0] + rad[2], 90 , x + width - cssSprite.style.borderRight[0] - rad[2],y + height - rad[2] - cssSprite.style.borderBottom[0]);								//g.beginFill(0x00FF00);				g.moveTo((x + width) - (cssSprite.style.borderRight[0] + rad[2]) , (y + height ) - ( cssSprite.style.borderBottom[0]));				g.lineTo((x + width ) - ( cssSprite.style.borderRight[0] + rad[2] ) ,y + height );				if(rad[2] != 0) g.curveTo(x + width,y + height, x + width ,(y + height ) - ( cssSprite.style.borderBottom[0] + rad[2]));				else{					g.lineTo(x + width ,y + height);					g.lineTo(x + width ,y + height - cssSprite.style.borderBottom[0]);				}				g.lineTo((x + width) - (cssSprite.style.borderRight[0] ) , (y + height ) - ( cssSprite.style.borderBottom[0] + rad[2]));				if(rad[2] != 0)				{					g.curveTo((x + width) - (cssSprite.style.borderRight[0] ) ,y + height - cssSprite.style.borderBottom[0] ,(x + width) - (cssSprite.style.borderRight[0] + rad[2]) , (y + height ) - ( cssSprite.style.borderBottom[0]));				}				else g.lineTo((x + width) - (cssSprite.style.borderRight[0] + rad[2]) , (y + height ) - ( cssSprite.style.borderBottom[0]));				g.endFill();			}									// corner bootom left			if(cssSprite.style.borderLeft[0] != 0 || cssSprite.style.borderBottom[0] != 0)			{								CssDraw.makeBorderGradient(g,cssSprite.style.borderLeft[1],cssSprite.style.borderBottom[1],cssSprite.style.borderLeft[2],cssSprite.style.borderBottom[2], cssSprite.style.borderLeft[0] + rad[3], cssSprite.style.borderBottom[0]  + rad[3], 45, x, y + height - rad[3] - cssSprite.style.borderBottom[0]);								//g.beginFill(0x00FF00);				g.moveTo(x + cssSprite.style.borderLeft[0] ,y + height - rad[3] - cssSprite.style.borderBottom[0]);				g.lineTo(x ,y + height - rad[3] - cssSprite.style.borderBottom[0]);				if(rad[3] != 0) g.curveTo(x,y + height ,x + rad[3] + cssSprite.style.borderLeft[0] ,y + height);				else {					g.lineTo(x ,y + height);					g.lineTo(x + cssSprite.style.borderLeft[0],y + height);				}				g.lineTo(x + rad[3] + cssSprite.style.borderLeft[0] ,y + height -  cssSprite.style.borderBottom[0]);				if(rad[3] != 0)				{					g.curveTo(x + cssSprite.style.borderLeft[0] ,y + height - cssSprite.style.borderBottom[0] ,x + cssSprite.style.borderLeft[0] ,y + height - rad[3] - cssSprite.style.borderBottom[0]);				}				else g.lineTo(x + cssSprite.style.borderLeft[0] ,y + height - rad[3] - cssSprite.style.borderBottom[0]);				g.endFill();			}								}				private static function makeBorderGradient(g:Graphics,color1:uint,color2:uint,alpha1:Number,alpha2:Number,width:Number,height:Number,rotation:Number,tx:Number = 0,ty:Number = 0):void		{			 var fillType:String = GradientType.LINEAR;			 var colors:Array = [color1,color2];			 var alphas:Array = [alpha1,alpha2];			 var ratios:Array = [0x00, 0xff];			 var matr:Matrix = new Matrix();			 var spreadMethod:String = SpreadMethod.PAD;			 			 matr.createGradientBox(width, height,  rotation, tx, ty);			 g.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);  		}				private static function drawBackGround(cssSprite:CoreCssSprite,x:Number,y:Number,width:Number,height:Number):void		{			if(!cssSprite.style.gradient) cssSprite.graphics.beginFill(cssSprite.style.backgroundColor,cssSprite.style.backgroundAlpha);			else 			{				cssSprite.style.gradient.matr = new Matrix();				cssSprite.style.gradient.matr.createGradientBox(width,height,cssSprite.style.gradient.rotation,cssSprite.style.gradient.matr.tx,cssSprite.style.gradient.matr.ty);				cssSprite.graphics.beginGradientFill(														cssSprite.style.gradient.fillType,														cssSprite.style.gradient.colors,														cssSprite.style.gradient.alphas,														cssSprite.style.gradient.ratios,														cssSprite.style.gradient.matr,														cssSprite.style.gradient.spreadMethod													);							}						CssDraw.drawSahpe(cssSprite,x,y,width,height);		}				private static function drawSahpe(cssSprite:CoreCssSprite,x:Number,y:Number,width:Number,height:Number):void		{			if(cssSprite.style.borderRadius[0] == 0 && cssSprite.style.borderRadius[1] == 0 && cssSprite.style.borderRadius[2] == 0 && cssSprite.style.borderRadius[3] == 0)				cssSprite.graphics.drawRect(x,y,width,height);			else if(cssSprite.style.borderRadius[0] == cssSprite.style.borderRadius[1] && cssSprite.style.borderRadius[0] == cssSprite.style.borderRadius[2] && cssSprite.style.borderRadius[0] == cssSprite.style.borderRadius[3] && cssSprite.style.borderRadius[3] != 0 )				cssSprite.graphics.drawRoundRect(x,y,width,height,cssSprite.style.borderRadius[1]);			else drawComplexeSahpe(cssSprite,x,y,width,height);		}				private static function drawComplexeSahpe(cssSprite:CoreCssSprite,x:Number,y:Number,width:Number,height:Number):void		{			var g:Graphics = cssSprite.graphics;			var rad:Array = cssSprite.style.borderRadius;						g.moveTo(x,y + rad[0]);			g.curveTo(x,y,x + rad[0],y);			g.lineTo(( x + width ) - rad[1] ,y);			g.curveTo(( x + width ),y,( x + width ) ,y + rad[1]);			g.lineTo(( x + width ) ,( y + height) - rad[2]);			g.curveTo(( x + width ),( y + height ) ,( x + width )  - rad[2] ,( y + height ));			g.lineTo( x + rad[3]  ,( y + height));			g.curveTo(x ,( y + height ) , x  ,( y + height ) - rad[3]);			g.lineTo(x,y + rad[0]);					}	}	}